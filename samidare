#!/usr/bin/env ruby

$KCODE = 'e'

require 'xtemplate'
require 'open-uri'
require 'uri'
require 'time'
require 'resolv-replace'
require 'yaml'
require 'tidy'
require 'iconv'
require 'timeout'
require 'net/http'
require 'pp'
require 'optparse'
require 'rexml/document'
require 'zlib'
require 'lirs'

CONFIG_FILENAME = 'config.yml'
STATUS_FILENAME = 'status.rm'

TEMPLATE_LATEST_FILENAME = 't.latest.html'
OUTPUT_LATEST_FILENAME = 'latest.html'

class Entry
  ENTRIES = {}

  def initialize(hash, config)
    @hash = hash
    @config = config
    ENTRIES[@hash['URI']] = self
    ENTRIES[@hash['LinkURI']] = self if @hash['LinkURI']
  end
  attr_reader :hash
  attr_reader :config

  def update_info?
    @config.include? 'UpdateInfo'
  end

  def should_check?
    ARGV.empty? or
    ARGV.include?(@config['URI']) or
    @config['LinkURI'] && ARGV.include?(@config['LinkURI']) or
    @hash['_update_info']
  end

  DefaultMinimumInterval = 5 * 60
  DefaultMaximumInterval = 24 * 60 * 60
  def timing_check
    t1 = next_timing
    t2 = Time.now
    t1 <= t2
  end

  def expect_next_by_periodical
    h = find_last_200
    return nil unless h
    periodical = h['periodical']
    return nil unless periodical 
    return nil if periodical.length < 2
    last_modified = periodical.last
    intervals = []
    prev = nil
    periodical.each {|curr|
      intervals << curr - prev if prev
      prev = curr
    }
    t = last_modified + intervals.min
    begin # adjust server/client time difference
      t += (h['clientDateEnd'] || h['clientDateBeg']) - Time.httpdate(h['serverDateString'])
    rescue
    end
    t
  end

  def next_timing
    if @hash['_update_info']
      Time.now
    elsif e1 = find_first_error
      min = @config.fetch('MinimumInterval', DefaultMinimumInterval) # xxx: should support units other than second.
      e2 = find_last_error
      e1t = e1['clientDateEnd']
      e2t = e2['clientDateEnd']
      if e1.equal? e2
        e1t + min
      else
        e2t + (e2t - e1t)
      end
    elsif s1 = find_first_200_with_current_content # Is there any 200?
      min = @config.fetch('MinimumInterval', DefaultMinimumInterval) # xxx: should support units other than second.
      max = @config.fetch('MaximumInterval', DefaultMaximumInterval)
      min = max if max < min

      s2 = find_last_success
      s2t = s2['clientDateEnd'] || s2['clientDateBeg']

      if @config['Periodical']
        s1t = expect_next_by_periodical
        return s1t if s1t && s2t < s1t
      end
      if !s1t
        begin
          s1t = Time.httpdate(s1['lastModifiedString']) +
            ((s1['clientDateEnd'] || s1['clientDateBeg']) - Time.httpdate(s1['serverDateString']))
        rescue
          s1t = s1['clientDateEnd'] || s1['clientDateBeg']
        end
        s1t = s2t if s2t < s1t
      end

      r = s2t + (s2t - s1t)
      if r < s2t + min
        s2t + min
      elsif s2t + max < r
        s2t + max
      else
        r
      end
    else
      Time.now
    end
  end

  def check
    uri = @config['URI']
    @hash['_log'] = [] unless @hash['_log']

    client_date_1 = Time.now
    STDERR.puts "#{client_date_1.iso8601} fetch start #{uri}" if $VERBOSE
    opts = {"User-Agent"=>"samidare"}
    if h = find_last_200
      if @config.fetch('UseIfModifiedSince', true)
        opts['If-Modified-Since'] = h['lastModifiedString'] if h['lastModifiedString']
      end
      opts['If-None-Match'] = h['eTag'] if h['eTag']
    end
    #PP.pp([uri, opts], STDERR) if $VERBOSE
    page = nil
    meta = nil
    status = nil
    status_message = nil
    trouble = nil
    begin
      page = timeout(@config['Timeout'] || 200) { URI.parse(uri).read(opts) }
      meta = page.meta
      status = page.status[0]
      status_message = page.status[1]
    rescue OpenURI::HTTPError
      if $!.io.status.first == '304'
        meta = $!.io.meta
        status = $!.io.status[0]
        status_message = $!.io.status[1]
      else
        meta = $!.io.meta
        status = $!.io.status[0]
        status_message = $!.io.status[1]
        trouble = "#{status} #{status_message}"
      end
    rescue StandardError, TimeoutError
      trouble = $!.message
    end
    client_date_2 = Time.now
    STDERR.puts "#{client_date_2.iso8601} fetch end #{trouble || "#{status} #{status_message}"} #{uri}" if $VERBOSE

    h = @config.dup
    h['status'] = status
    h['statusMessage'] = status_message if status_message
    h['serverDateString'] = meta['date'] if meta && meta['date']

    if @config['LogMeta']
      h['logSendHeader'] = opts
      h['logRecvHeader'] = meta
    end

    if page
      h['baseURI'] = page.base_uri.to_s if page.base_uri.to_s != uri
      h['lastModifiedString'] = meta['last-modified'] if meta['last-modified']
      h['eTag'] = meta['etag'] if meta['etag']
      content_type = h['contentType'] = page.content_type if page.content_type
      content_charset = page.charset { @config['DefaultCharset'] || page.guess_charset }
      content_charset = content_charset.downcase
      h['contentCharset'] = content_charset
      content = page
      if !page.content_encoding.empty?
        content_encoding = page.content_encoding.dup
        while !content_encoding.empty?
          case content_encoding.last
          when 'gzip', 'x-gzip'
            content = content.decode_gzip
          when 'deflate'
            content = content.decode_deflate
          else
            break
          end
          content_encoding.pop
        end
        content_encoding = nil if content_encoding.empty?
        h['contentEncoding'] = content_encoding if content_encoding
      end
      if content_type == 'text/html' && !content_encoding
        t = Tidy.parse_string(content, :encoding=>content_charset).head.children.find {|n| n.title? && !n.children.empty? && !n.children[0].text.empty? }.children[0]
        h['extractedTitle'] = t.text.chomp.decode_charset(content_charset).decode_html_escape.gsub(/\0/, '') if t
        if @config['ChecksumXPath']
          t = Iconv.iconv("utf-8", content_charset, content).join
          t = Tidy.parse_string(t, "output-xml"=>true, :encoding=>"UTF-8").dump
          t.gsub!(%r{<\n\/}, '</')
          begin
            checksum_target = ''
            REXML::Document.new(t).elements.each(@config['ChecksumXPath']) {|e| e.write checksum_target }
            h['checksum'] = checksum_target.sum
          rescue REXML::ParseException
          end
        end
      end
      h['checksum'] = content.sum unless h['checksum']

      if @config['UpdateInfo'] == 'lirs' && !content_encoding
        check_lirs(content)
        h['content'] = String.new(content)
      end
    end

    h['trouble'] = trouble if trouble
    h['clientDateBeg'] = client_date_1
    h['clientDateEnd'] = client_date_2

    add_log(h)

    @hash.delete '_update_info'
  end

  def check_lirs(new_lirs)
    log = @hash['_log']
    old_lirs = nil
    log.reverse_each {|h|
      if h['content']
        old_lirs = h['content']
        break
      end
    }
    log.each {|h| h.delete 'content' }
    begin
      l1 = LIRS.decode(old_lirs) if old_lirs
      l2 = LIRS.decode(new_lirs)
      l2.each {|r2|
        uri = r2.target_url
        if !old_lirs or (r1 = l1[uri] and r1.last_modified != r2.last_modified)
          if e = ENTRIES[uri]
            t1 = Time.at(r1.last_modified.to_i) if old_lirs
            t2 = Time.at(r2.last_modified.to_i)
            if e.find_last_success['clientDateEnd'] < t2 #xxx: not so acculate.
              p [:LIRS_UPDATE, uri, t1, t2, @config['URI']]
              ENTRIES[uri].hash['_update_info'] = true
            end
          end
        end
      }
    rescue
      # External update information is a just hint.
      # So it is ignorable even if it has some trouble.
    end
  end

  StatusMap = {
    '200' => 's', # Success
    '304' => 'n', # Not-Modified
  }
  StatusMap.default = 'e' # Error

  MaxPeriodicalNum = 10
  def add_periodical_info(h)
    return if h['status'] != '200'

    log = @hash['_log']

    periodical = nil
    log.reverse_each {|l|
      if l['periodical']
        periodical = l['periodical'].dup
        break
      end
    }
    periodical ||= []

    begin
      t = Time.httpdate(h['lastModifiedString'])
    rescue ArgumentError
    end

    if t && (periodical.empty? || periodical.last != t)
      periodical << t
    end

    if MaxPeriodicalNum < periodical.length
      periodical = periodical[(-MaxPeriodicalNum)..(-1)]
    end

    h['periodical'] = periodical if !periodical.empty?
  end

  def add_log(h)
    @hash['_log'] = [] unless @hash['_log']

    #add_periodical_info(h) if @config['Periodical']
    add_periodical_info(h)

    log = @hash['_log']
    history = log.map {|l| StatusMap[l['status']] }.join + ' ' + StatusMap[h['status']]

    case history
    when /ee e/
      log.pop
    when /e e/
    when / e/
    when /e+ [sn]/
      log.pop while !log.empty? && StatusMap[log.last['status']] == 'e'
      history.sub!(/e+ /, ' ')
    end

    case history
    when / e/
    when ' s'
    when 's s'
      log.clear unless log[0]['checksum'] && h['checksum'] && log[0]['checksum'] == h['checksum']
    when 's n'
    when 'ss s'
      (log[0]['checksum'] && h['checksum'] && log[0]['checksum'] == h['checksum']) ? log.pop : log.clear
    when 'ss n'
    when 'sn s'
      (log[0]['checksum'] && h['checksum'] && log[0]['checksum'] == h['checksum']) ? log.pop : log.clear
    when 'sn n'
      log.pop
    when 'ssn s'
      (log[0]['checksum'] && h['checksum'] && log[0]['checksum'] == h['checksum']) ? (log.pop; log.pop) : log.clear
    when 'ssn n'
      log.pop
    else
      log.clear
    end
    log << h
  end

  def find_first_200_with_current_content
    result = nil
    @hash['_log'].reverse_each {|h|
      if h['status'] == '200'
        if !result
          result = h
        elsif result['checksum'] != h['checksum'] || result['ChecksumXPath'] != h['ChecksumXPath']
          return result
        else
          result = h
        end
      end
    }
    result
  end

  def find_last_200
    @hash['_log'].reverse_each {|h|
      return h if h['status'] == '200'
    }
    nil
  end

  def find_last_success
    @hash['_log'].reverse_each {|h|
      return h if StatusMap[h['status']] != 'e'
    }
    nil
  end

  def find_first_error
    @hash['_log'].each {|h|
      return h if StatusMap[h['status']] == 'e'
    }
    nil
  end

  def find_last_error
    @hash['_log'].reverse_each {|h|
      return h if StatusMap[h['status']] == 'e'
    }
    nil
  end

  def presentation_data
    h = @config.dup
    log = @hash['_log']
    h.update @hash # xxx
    h['title'] = h['Title']
    h['last-modified'] = '- no log -'
    unless log.empty?
      if l = find_first_200_with_current_content
        h['last-modified-found'] = l['clientDateBeg'] # xxx: clientDateEnd is better?
        if l.include? 'lastModifiedString'
          h['last-modified'] = Time.httpdate(l['lastModifiedString']).localtime.iso8601
          l2 = find_last_200
          unless l.equal? l2
            if l['lastModifiedString'] != l2['lastModifiedString']
              h['last-modified'] << '[Touch]'
            else
              h['last-modified'] << '[NoIMS]'
            end
          end
        else
          h['last-modified'] = l['clientDateBeg'].getlocal.iso8601 + '[NoLM]'
        end
        h['title'] ||= l['extractedTitle'] if l['extractedTitle']
      else
        l = log.last
        if l['status']
          if l['statusMessage']
            h['last-modified'] = "- #{l['status']} #{l['statusMessage']} -"
          else
            h['last-modified'] = "- #{l['status']} -"
          end
        elsif l['trouble']
          h['last-modified'] = "- #{l['trouble']} -"
        else
          h['last-modified'] = '- no status -'
        end
      end
    end
    h['title'] ||= h['LinkURI'] if h['LinkURI']
    h['title'] ||= h['URI']

    h
  end

  def merge(hash)
    @hash = hash.dup.update(@hash)
  end
end

module Enumerable
  def concurrent_map(max_threads=8)
    arr = self.to_a.dup
    queue = (0...arr.length).to_a

    max_threads = arr.length if arr.length < max_threads

    threads = []
    max_threads.times {
      threads << Thread.new {
        while i = queue.shift
          arr[i] = yield arr[i]
        end
      }
    }

    threads.each {|t| t.join }
    arr
  end
end

class String
  def guess_charset
    case self
    when /\A[\s\x21-\x7e]*\z/
      "us-ascii"
    when /\A[\s\x21-\x7e]*                      (?# initial ascii )
            (\e\(B[\s\x21-\x7e]*                (?# ascii )
            |\e\(J[\s\x21-\x7e]*                (?# JIS X 0201 )
            |\e\$@(?:[\x21-\x7e][\x21-\x7e])*   (?# JIS X 0201 )
            |\e\$B(?:[\x21-\x7e][\x21-\x7e])*   (?# JIS X 0201 )
            )*\z/nx
      "iso-2022-jp"
    when /\A[\s\x21-\x7e]*                      (?# initial ascii )
            (\e\(B[\s\x21-\x7e]*                (?# ascii )
            |\e\(J[\s\x21-\x7e]*                (?# JIS X 0201 latin )
            |\e\(I[\s\x21-\x7e]*                (?# JIS X 0201 katakana )
            |\e\$@(?:[\x21-\x7e][\x21-\x7e])*   (?# JIS X 0201 )
            |\e\$B(?:[\x21-\x7e][\x21-\x7e])*   (?# JIS X 0201 )
            )*\z/nx
      "iso-2022-jp" # with katakana
    when /\A(?:\s                               (?# white space character)
            | [\x21-\x7e]                       (?# JIS X 0201 Latin)
            | ([\xa1-\xdf])                     (?# JIS X 0201 Katakana)
            | [\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]      (?# JIS X 0208)
            | ([\xf0-\xfc][\x40-\x7e\x80-\xfc]) (?# extended area)
            )*\z/nx
      "shift_jis"
    when /\A(?:\s                               (?# white space character)
            | [\x21-\x7e]                       (?# ASCII)
            | [\xa1-\xfe][\xa1-\xfe]            (?# JIS X 0208)
            | \x8e(?:([\xa1-\xdf])              (?# JIS X 0201 Katakana)
                    |([\xe0-\xfe]))             (?# There is no character in E0 to FE)
            | \x8f[\xa1-\xfe][\xa1-\xfe]        (?# JIS X 0212)
            )*\z/nx
      "euc-jp"
    when /\A(?:\s
            | [\x21-\x7e]
            | [\xc0-\xdf][\x80-\xbf]
            | [\xe0-\xef][\x80-\xbf][\x80-\xbf]
            | [\xf0-\xf7][\x80-\xbf][\x80-\xbf][\x80-\xbf]
            | [\xf8-\xfb][\x80-\xbf][\x80-\xbf][\x80-\xbf][\x80-\xbf]
            | [\xfc-\xfd][\x80-\xbf][\x80-\xbf][\x80-\xbf][\x80-\xbf][\x80-\xbf]
            )*\z/nx
      "utf-8" # may be redundunt.
    else
      "iso-8859-1"
    end
  end

  HTMLDecodeEscape = {
    'amp' => '&',
    'lt' => '<',
    'gt' => '>',
    'quot' => '"',
  }
  def decode_html_escape
    self.gsub(/&(amp|lt|gt|quot);/) { HTMLDecodeEscape[$1] }
  end

  def decode_gzip
    Zlib::GzipReader.new(StringIO.new(self)).read
  end

  def decode_deflate
    Zlib::Inflate.inflate(self)
  end
end

class Iconv
  def Iconv.internal_charset
    case $KCODE
    when /\Ae/i; 'euc-jp'
    when /\As/i; 'shift_jis'
    when /\Au/i; 'utf-8'
    when /\An/i; 'iso-8859-1'
    else
      raise "unknown $KCODE: #{$KCODE.inspect}"
    end
  end

  def Iconv.conv(to, from, str)
    begin
      Iconv.iconv(to, from, str).join
    rescue Iconv::IllegalSequence
      p [:IllegalSequence, str]
      ""
    end
  end
end

class String
  def decode_charset(charset)
    Iconv.conv(Iconv.internal_charset, charset, self)
  end

  def encode_charset(charset)
    Iconv.conv(charset, Iconv.internal_charset, self)
  end
end

class Webpecker
  def open_lock(filename, nonblock=false)
    dirname = File.dirname filename
    basename = File.basename filename
    tmpname = "#{dirname}/.,#{basename},#$$"

    1.times {
      begin
        target = File.open(filename, File::RDWR|File::CREAT)
        stat1 = target.stat
        if nonblock
          return unless target.flock(File::LOCK_EX | File::LOCK_NB)
        else
          target.flock(File::LOCK_EX)
        end
        stat2 = File.stat(filename)
        redo if stat1.ino != stat2.ino

        begin
          File.open(tmpname, 'w') {|tmp|
            yield target, tmp
          }
          stat2 = File.stat(filename) # manually unlocked?
          File.rename(tmpname, filename) if stat1.ino == stat2.ino
        ensure
          File.unlink tmpname if FileTest.exist? tmpname
        end
      ensure
        target.close if target
      end
    }
  end

  def config_flatten(arr, default={})
    result = []
    arr.each {|elt|
      case elt
      when Hash
        if elt.include? 'URI'
          result << default.dup.update(elt)
        else
          default = default.dup.update(elt)
        end
      when Array
        result.concat config_flatten(elt, default)
      when String
        result << default.dup.update({'URI'=>elt})
      end
    }
    result
  end

  def deep_copy(o)
    Marshal.load(Marshal.dump(o))
  end

  def deep_freeze(o)
    objs = []
    o = Marshal.load(Marshal.dump(o), lambda {|obj| objs << obj })
    objs.each {|obj| obj.freeze }
    o
  end

  def load_config
    config = config_flatten(File.open(CONFIG_FILENAME) {|f| YAML.load(f) })
    config.each {|h|
      h.reject! {|k, v| /\A[A-Z]/ !~ k }
    }
    config
  end

  #def load_status(f) YAML.load(f) end
  #def save_status(f, d) f.puts d.to_yaml end
  def load_status(f) Marshal.load(f) end
  def save_status(d, f) Marshal.dump(d, f) end

  def open_status(readonly=false)
    if readonly
      open(STATUS_FILENAME) {|f|
        if f.stat.size == 0
          status = []
        else
          status = load_status(f)
        end
        status = deep_freeze(status)
        yield status
      }
    else
      open_lock(STATUS_FILENAME, true) {|f, out|
        if f.stat.size == 0
          status = []
        else
          status = load_status(f)
        end
        yield status
        save_status(status, out)
      }
    end
  end

  def generate_output(data)
    data = deep_copy(data)
    result = XTemplate::XMLTemplate.new(File.read(@opt_template)).expand(data)
    result.gsub!(/&apos;/, "'")
    if @opt_output != '-'
      dir = File.dirname @opt_output
      if FileTest.writable? dir
        output_new = @opt_output + '.new'
        open(output_new, 'w') {|f|
          f.puts result
        }
        File.rename output_new, @opt_output
      else
        open(@opt_output, 'w') {|f|
          f.puts result
        }
      end
    else
      puts result
    end
  end

  def parse_options
    @opt_output = OUTPUT_LATEST_FILENAME
    @opt_dont_check = nil
    @opt_force_check = nil
    @opt_timing = nil
    @opt_dump_config = nil
    @opt_dump_status = nil
    @opt_dump_template_data = nil
    @opt_template = TEMPLATE_LATEST_FILENAME
    ARGV.options {|q|
      q.banner = 'webpecker [opts]'
      q.def_option('--help', 'show this message') {puts q; exit(0)}
      q.def_option('--verbose', '-v', 'verbose') { $VERBOSE = true }
      q.def_option('--no-check', '-n', 'don\'t check web') { @opt_dont_check = true }
      q.def_option('--force', '-f', 'force check (avoid timing control mechanism)') { @opt_force_check = true }
      q.def_option('--output=filename', '-o', 'specify output file') {|filename| @opt_output = filename }
      q.def_option('--template=filename', '-T', 'specify template') {|filename| @opt_template = filename }
      q.def_option('--timing', '-t', 'show timings') { @opt_timing = true }
      q.def_option('--dump-config', 'dump flatten configuration') { @opt_dump_config = true }
      q.def_option('--dump-status', 'dump status') { @opt_dump_status = true }
      q.def_option('--dump-template-data', 'dump data for expand template') { @opt_dump_template_data = true }
      q.parse!
    }
  end

  def create_entries(config, status, readonly=false)
    logs = {}
    status.each {|status_ent|
      if status_ent.include?('URI') && status_ent.include?('_log')
        logs[status_ent['URI']] = status_ent['_log']
      end
    }

    status.clear unless readonly

    entries = []
    config.each {|config_ent|
      uri = config_ent['URI']
      log = logs[uri] || []
      status_ent = { 'URI' => uri, '_log' => log }
      status << status_ent unless readonly
      entries << Entry.new(status_ent, config_ent)
    }
    entries
  end

  def main
    parse_options
    config = load_config
    if @opt_dump_config
      puts config.to_yaml
      return
    end
    data = nil
    readonly = @opt_timing || @opt_dont_check || @opt_dump_status || @opt_dump_template_data
    open_status(readonly) {|status|
      if @opt_dump_status
        pp status
        return
      end
      entries = create_entries(config, status, readonly)
      if @opt_timing
        entries.map {|entry|
          [entry.next_timing.localtime, entry]
        }.sort.each {|timing, entry|
          h = entry.presentation_data
          s = "#{timing}: #{h['title']}"
          s << "(#{h['Author']})" if h['Author']
          puts s
        }
      else
        unless readonly
          entries.concurrent_map {|entry|
            next unless entry.update_info?
            entry.check if entry.should_check? && (@opt_force_check || entry.timing_check)
          }
          entries.concurrent_map {|entry|
            next if entry.update_info?
            entry.check if entry.should_check? && (@opt_force_check || entry.timing_check)
          }
        end
        entries.reject! {|entry| entry.update_info? }
        data = {
          "antenna" =>
          entries.map {|entry| entry.presentation_data }.sort_by {|h|
            # [h['last-modified'], h['title']]
            if h['last-modified-found']
              [1, h['last-modified-found'], h['last-modified'], h['title']]
            else
              [0, h['last-modified'], h['title']]
            end
          }.reverse
        }
        if @opt_dump_template_data
          pp data
          return
        end
        generate_output(data)
      end
    }
    #PP.pp(data, STDERR) if $VERBOSE
  end

end

if $0 == __FILE__
  Webpecker.new.main
end
